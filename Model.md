#编程模型

## 事件驱动模型
执行流由外部事件来决定,当外部事件发生时使用回调机制出发相应的处理<br/>
流程: *开始--->初始化--->等待*

1. 事件(消息)队列
2. 鼠标按下时,在队列中增加一个事件
3. 循环不断从队列取出事件,调用不同函数
4. 事件一般各自单独保存各自的处理函数指针,使得各事件可以独立处理

## linux下的IO五种模型
### 概览
**网络通信被Unix系统抽象为文件的读写**<br/>
对于一个network IO来说,通常涉及两个系统对象(调用IO的process/thread;系统内核kernel)以及两个阶段:

1. 等待数据准备(waiting for the data to be ready)
2. 将数据从内核拷贝到进程中(copying the data from the kernel to the process)
### 分类
+ 阻塞IO (blocking IO)<br/>
两个过程都会直接阻塞
+ 非阻塞IO (nonblocking IO)<br/>
用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU 
且收发数据无法及时
+ 多路复用 (IO multiplexing)<br/>
有一个线程不断去轮询多个socket的状态(因为在多路复用IO模型中, 只需要使用一个线程就可以管理多个socket, 系统不需要建立新的进程或者线程, 所以它大大减少了资源占用)<br/>
此外, 在非阻塞IO中, 不断地询问socket状态是通过用户线程去进行的, 而在多路复用IO中, 轮询每个socket状态是内核在进行的, 这个效率要比用户线程要高的多
+ 异步IO (asynchronous IO)<br/>
IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成
+ 信号驱动IO (signal driven IO)<br/>
当用户线程发起一个IO请求操作, 会给对应的socket注册一个信号函数. 然后用户线程会继续执行, 当内核数据就绪时会发送一个信号给用户线程, 用户线程接收到信号之后, 便在信号函数中调用IO读写操作来进行实际的IO请求操作

### IO多路复用的三种方法
1. select
2. poll
3. epoll