<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>编程模型</title>    
    </head>
    <body>
        <div>
            <h2 onclick="func">
                事件驱动模型
            </h2>
            <strong>执行流由外部事件来决定,当外部事件发生时使用回调机制出发相应的处理</strong><br>
            <strong>流程</strong>:
            <i>开始--->初始化--->等待</i></br>
            <ol>
                <li>
                    事件(消息)队列
                </li>
                <li>
                    鼠标按下时,在队列中增加一个事件
                </li>
                <li>
                    循环不断从队列取出事件,调用不同函数
                </li>
                <li>
                    事件一般各自单独保存各自的处理函数指针,使得各事件可以独立处理
                </li>
            </ol>
            <h2>
                多线程
            </h2>
            <h2>
                单线程
            </h2>
        </div>
        <div>
            <h3>
                linux下的IO五种模型
            </h3>
            <p> &nbsp;&nbsp;&nbsp;&nbsp;
                对于一个network IO来说,通常涉及两个系统对象(调用IO的process/thread;系统内核kernel)<br>&nbsp;&nbsp;&nbsp;&nbsp;
                以及两个阶段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                1) 等待数据准备(waiting for the data to be ready)&nbsp;&nbsp;&nbsp;&nbsp;
                2) 将数据从内核拷贝到进程中(copying the data from the kernel to the process)
            </p>
            <ul>
                <li>
                    <strong>阻塞IO (blocking IO)</strong>
                    <br>&nbsp;&nbsp;&nbsp;&nbsp;
                    两个过程都会直接阻塞
                </li>
                <li>
                    <strong>非阻塞IO (nonblocking IO)</strong>
                    <br>&nbsp;&nbsp;&nbsp;&nbsp;
                    用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU
                    <br>&nbsp;&nbsp;&nbsp;&nbsp;
                    且收发数据无法及时
                </li>
                <li>
                    <strong>多路复用 (IO multiplexing)</strong>
                    <br>&nbsp;&nbsp;&nbsp;&nbsp;
                    有一个线程不断去轮询多个socket的状态(因为在多路复用IO模型中, 只需要使用一个线程就可以管理多个socket, 系统不需要建立新的进程或者线程, 所以它大大减少了资源占用)
                    <br>&nbsp;&nbsp;&nbsp;&nbsp;
                    此外, 在非阻塞IO中, 不断地询问socket状态是通过<i>用户线程</i>去进行的, 而在多路复用IO中, 轮询每个socket状态是<i>内核</i>在进行的, 这个效率要比用户线程要高的多
                </li>
                <li>
                    <strong>异步IO (asynchronous IO)</strong>
                    <br>&nbsp;&nbsp;&nbsp;&nbsp;
                    IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成
                </li>
                <li>
                    <strong>信号驱动IO (signal driven IO)</strong>
                    <br>&nbsp;&nbsp;&nbsp;&nbsp;
                    当用户线程发起一个IO请求操作, 会给对应的socket注册一个信号函数. 然后用户线程会继续执行, 当内核数据就绪时会发送一个信号给用户线程, 用户线程接收到信号之后, 便在信号函数中调用IO读写操作来进行实际的IO请求操作
                </li>
            </ul>
            <h3>
                IO多路复用的三种方法
            </h3>
            <ul>
                <li>
                    <strong>select</strong>
                </li>
                <li>
                    <strong>poll</strong>
                </li>
                <li>
                    <strong>epoll</strong>
                </li>
            </ul>
        </div>
    </body>
</html>